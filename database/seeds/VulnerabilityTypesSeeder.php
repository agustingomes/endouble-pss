<?php

use Illuminate\Database\Seeder;
use App\Models\VulnerabilityType;

class VulnerabilityTypesSeeder extends Seeder
{
    /**
     * Run the database seeds.
     *
     * @return void
     */
    public function run()
    {
        VulnerabilityType::firstOrCreate([
            'code' => 'AUTHBYPASS',
            'name' => 'Authentication Bypass',
        ])->fill([
            'description' => 'While most applications require authentication to gain access to private information or to execute tasks, not every authentication method is able to provide adequate security. Negligence, ignorance, or simple understatement of security threats often result in authentication schemes that can be bypassed by simply skipping the log in page and directly calling an internal page that is supposed to be accessed only after authentication has been performed.\n\nIn addition, it is often possible to bypass authentication measures by tampering with requests and tricking the application into thinking that the user is already authenticated. This can be accomplished either by modifying the given URL parameter, by manipulating the form, or by counterfeiting sessions.',
            'attack_details' => '',
            'remediation' => '',
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'RFI',
            'name' => 'Remote File Inclusion',
        ])->fill([
            'severity' => 4,
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'REDIRECT',
            'name' => 'Open redirect',
        ])->fill([
            'severity' => 3,
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'RCE',
            'name' => 'Remote Code Execution',
        ])->fill([
            'severity' => 4,
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'MULTI',
            'name' => 'Multiple vulnerabilities',
        ]);

        VulnerabilityType::firstOrCreate([
            'code' => 'LFI',
            'name' => 'Local File Inclusion',
        ])->fill([
            'severity' => 4,
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'FPD',
            'name' => 'Full Path Disclosure',
        ])->fill([
            'severity' => 1,
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'DOS',
            'name' => 'Denial of Service',
        ])->fill([
            'severity' => 3,
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'CSRF',
            'name' => 'Cross Site Request Forgery',
        ])->fill([
            'severity' => 3,
            'description' => 'Cross-site request forgery (CSRF) vulnerabilities may arise when applications rely solely on HTTP cookies to identify the user that has issued a particular request. Because browsers automatically add cookies to requests regardless of their origin, it may be possible for an attacker to create a malicious web site that forges a cross-domain request to the vulnerable application. For a request to be vulnerable to CSRF, the following conditions must hold:\n\n
            - The request can be issued cross-domain, for example using an HTML form. If the request contains non-standard headers or body content, then it may only be issuable from a page that originated on the same domain.\n
            - The application relies solely on HTTP cookies or Basic Authentication to identify the user that issued the request. If the application places session-related tokens elsewhere within the request, then it may not be vulnerable.\n
            - The request performs some privileged action within the application, which modifies the application\'s state based on the identity of the issuing user.\n
            - The attacker can determine all the parameters required to construct a request that performs the action. If the request contains any values that the attacker cannot determine or predict, then it is not vulnerable.',
            'attack_details' => '',
            'remediation' => "The most effective way to protect against CSRF vulnerabilities is to include within relevant requests an additional token that is not transmitted in a cookie: for example, a parameter in a hidden form field. This additional token should contain sufficient entropy, and be generated using a cryptographic random number generator, such that it is not feasible for an attacker to determine or predict the value of any token that was issued to another user. The token\n should be associated with the user's session, and the application should validate that the correct token is received before performing any action resulting from the request.\n\n
            An alternative approach, which may be easier to implement, is to validate that Host and Referer headers in relevant requests are both present and contain the same domain name. However, this approach is somewhat less robust: historically, quirks in browsers and plugins have often enabled attackers to forge cross-domain requests that manipulate these headers to bypass such defenses.",
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'BYPASS',
            'name' => 'Bypass',
        ])->fill([
            'severity' => 4,
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'SQLI',
            'name' => 'SQL Injection',
        ])->fill([
            'severity' => 4,
            'description' => '',
            'attack_details' => '',
            'remediation' => '',
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'SSRF',
            'name' => 'Server Side Request Forgery',
        ])->fill([
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'UNKNOWN',
            'name' => 'Unknown',
        ]);

        VulnerabilityType::firstOrCreate([
            'code' => 'UPLOAD',
            'name' => 'Arbitrary File Upload',
        ])->fill([
            'severity' => 4,
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'XSS',
            'name' => 'Cross Site Scripting',
        ])->fill([
            'severity' => 3,
            'description' => "",
            'attack_details' => "The attacker-supplied code can perform a wide variety of actions, such as stealing the victim's session token or login credentials, performing arbitrary actions on the victim's behalf, and logging their keystrokes.",
            'remediation' => "",
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'XXE',
            'name' => 'XML External Entity Process',
        ])->fill([
            'severity' => 4,
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'CSS',
            'name' => 'CSS Injection',
        ])->fill([
            'severity' => 3,
            'description' => 'CSS injection vulnerabilities arise when an application imports a style sheet from a user-supplied URL, or embeds user input in CSS blocks without adequate escaping. They are closely related to cross-site scripting (XSS) vulnerabilities but often trickier to exploit.\n\n
            Being able to inject arbitrary CSS into the victim\'s browser may enable various attacks, including:\n
            - Executing arbitrary JavaScript using IE\'s expression() function.\
            - Using CSS selectors to read parts of the HTML source, which may include sensitive data such as anti-CSRF tokens.\n
            - Capturing any sensitive data within the URL query string by making a further style sheet import to a URL on the attacker\'s domain, and monitoring the incoming Referer header.',
            'attack_details' => '',
            'remediation' => '',
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'SSLCERT',
            'name' => 'SSL Certificate',
        ])->fill([
            'severity' => 3,
            'description' => "SSL (or TLS) helps to protect the confidentiality and integrity of information in transit between the browser and server, and to provide authentication of the server's identity. To serve this purpose, the server must present an SSL certificate that is valid for the server's hostname, is issued by a trusted authority and is valid for the current date. If any one of these requirements is not met, SSL connections to the server will not provide the full protection for which SSL is designed.\n\n
            It should be noted that various attacks exist against SSL in general, and in the context of HTTPS web connections in particular. It may be possible for a determined and suitably-positioned attacker to compromise SSL connections without user detection even when a valid SSL certificate is used.",
            'attack_details' => 'An attacker performing a Man in the Middle, might be able to read and modify the traffic between the victim and the servers.',
            'remediation' => '',
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'HSTS',
            'name' => 'Missing Strict Transport Security Headers',
        ])->fill([
            'severity' => 3,
            'description' => "The application fails to prevent users from connecting to it over unencrypted connections. An attacker able to modify a legitimate user's network traffic could bypass the application's use of SSL/TLS encryption, and use the application as a platform for attacks against its users. This attack is performed by rewriting HTTPS links as HTTP, so that if a targeted user follows a link to the site from an HTTP page, their browser never attempts to use an encrypted connection. The sslstrip tool automates this process.",
            'attack_details' => "To exploit this vulnerability, an attacker must be suitably positioned to intercept and modify the victim's network traffic.This scenario typically occurs when a client communicates with the server over an insecure connection such as public Wi-Fi, or a corporate or home network that is shared with a compromised computer. Common defenses such as switched networks are not sufficient to prevent this. An attacker situated in the user's ISP or the application's hosting infrastructure could also perform this attack. Note that an advanced adversary could potentially target any connection made over the Internet's core infrastructure.",
            'remediation' => '[Fixing vulnerabilities guide: Headers - Strict-Transport-Security (HSTS)](https://netwerven.atlassian.net/wiki/display/SEC/Fixing+vulnerabilities+guide#Fixingvulnerabilitiesguide-Strict-Transport-Security(HSTS))',
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'XFRAMEOPTIONS',
            'name' => 'Missing X-Frame-Options Headers',
        ])->fill([
            'severity' => 2,
            'description' => "The X-Frame-Options Header setting is either inadequate or missing.",
            'attack_details' => "Client may be vulnerable to clickjacking attacks.",
            'remediation' => '[Fixing vulnerabilities guide: Headers - X-Frame-Options](https://netwerven.atlassian.net/wiki/display/SEC/Fixing+vulnerabilities+guide#Fixingvulnerabilitiesguide-X-Frame-Options)',
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'XXSS',
            'name' => 'Missing X-XSS-Protection Headers',
        ])->fill([
            'severity' => 2,
            'description' => "The X-XSS-Protection Header setting is either inadequate or missing.",
            'attack_details' => "Client may be vulnerable to Cross-Site Scripting Attacks.",
            'remediation' => '[Fixing vulnerabilities guide: Headers - X-XSS-Protection](https://netwerven.atlassian.net/wiki/display/SEC/Fixing+vulnerabilities+guide#Fixingvulnerabilitiesguide-X-XSS-Protection)',
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'XCTO',
            'name' => 'Missing X-Content-Type-Options Headers',
        ])->fill([
            'severity' => 2,
            'description' => "The X-Content-Type-Options Header setting is either inadequate or missing.",
            'attack_details' => "Attackers might able to perform drive-by download attacks.",
            'remediation' => '[Fixing vulnerabilities guide: Headers - X-Content-Type-Options](https://netwerven.atlassian.net/wiki/display/SEC/Fixing+vulnerabilities+guide#Fixingvulnerabilitiesguide-X-Content-Type-Option)',
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'ACAO',
            'name' => 'Access-Control-Allow-Origin Headers',
        ])->fill([
            'severity' => 2,
            'description' => "The Access-Control-Allow-Origin Header allows requests from any location.",
            'attack_details' => "Client may be vulnerable to Cross-Domain Scripting Attacks.",
            'remediation' => '[Fixing vulnerabilities guide: Headers - Access-Control-Allow-Origin](https://netwerven.atlassian.net/wiki/display/SEC/Fixing+vulnerabilities+guide#Fixingvulnerabilitiesguide-Access-Control-Allow-Origin)',
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'HPKP',
            'name' => 'Missing Public-Key-Pins (HPKP) Headers',
        ])->fill([
            'severity' => 1,
            'description' => "The Public-Key-Pins Header setting is either inadequate or missing.",
            'attack_details' => "An attacker can perform MiTM attacks using rigue X.509 certiifcates. By whitelisting only the identities that the browser should trust, your users are protected in the event a certificate authority is compromised.",
            'remediation' => '[Fixing vulnerabilities guide: Headers - Public-Key-Pins (HPKP)](https://netwerven.atlassian.net/wiki/display/SEC/Fixing+vulnerabilities+guide#Fixingvulnerabilitiesguide-Public-Key-Pins(HPKP))',
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'XCSP',
            'name' => 'Missing X-Content-Security-Policy Headers',
        ])->fill([
            'severity' => 1,
            'description' => "The X-Content-Security-Policy Header setting is either inadequate or missing.",
            'attack_details' => "Client may be vulnerable to Cross-Site Scripting and Injection Attacks.",
            'remediation' => '[Fixing vulnerabilities guide: Headers - Content-Security-Policy](https://netwerven.atlassian.net/wiki/display/SEC/Fixing+vulnerabilities+guide#Fixingvulnerabilitiesguide-Content-Security-Policy(CSP))',
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'RP',
            'name' => 'Missing Referrer-Policy Headers',
        ])->fill([
            'severity' => 1,
            'description' => "The Referrer-Policy Header setting is either inadequate or missing.",
            'attack_details' => "3rd party websites might be able to obtain URL information based on referrer leaks.",
            'remediation' => '[Fixing vulnerabilities guide: Headers - Referrer Policy](https://netwerven.atlassian.net/wiki/display/SEC/Fixing+vulnerabilities+guide#Fixingvulnerabilitiesguide-ReferrerPolicy)',
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'COOKIES_HTTPONLY',
            'name' => 'Cookie without HttpOnly flag set',
        ])->fill([
            'severity' => 3,
            'description' => "If the HttpOnly attribute is set on a cookie, then the cookie's value cannot be read or set by client-side JavaScript. This measure makes certain client-side attacks, such as cross-site scripting, slightly harder to exploit by preventing them from trivially capturing the cookie's value via an injected script.",
            'remediation' => '[Fixing vulnerabilities guide: Cookies](https://netwerven.atlassian.net/wiki/display/SEC/Fixing+vulnerabilities+guide#Fixingvulnerabilitiesguide-Cookies)',
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'COOKIES_SECURE',
            'name' => 'Cookie without Secure flag set',
        ])->fill([
            'severity' => 3,
            'description' => "Secure flag prevents cookies from being sent in clear text (under HTTP). A man in the middle attack on the users network against a target website without the Secure flag will allow the attacker to retrieve the user\'s cookies.",
            'remediation' => '[Fixing vulnerabilities guide: Cookies](https://netwerven.atlassian.net/wiki/display/SEC/Fixing+vulnerabilities+guide#Fixingvulnerabilitiesguide-Cookies)',
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'COOKIES_SAMESITE',
            'name' => 'Cookie without SameSite flag set',
        ])->fill([
            'severity' => 2,
            'description' => "A CSRF attack on the target without the Same-Site flag, will allow the attacker to perform authenticated actions, using a valid existing session and victim interaction.",
            'remediation' => '[Fixing vulnerabilities guide: Cookies](https://netwerven.atlassian.net/wiki/display/SEC/Fixing+vulnerabilities+guide#Fixingvulnerabilitiesguide-Cookies)',
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'SSLQUALYS',
            'name' => 'Qualys SSL Score',
        ])->fill([
            'description' => "The Qualys SSL report indicated a non-perfect SSL score. Check the results for more information.",
            'remediation' => '[https://www.ssllabs.com/ssltest/analyze.html]',
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'SSLDATESOON',
            'name' => 'SSL Certificate expires soon',
        ])->fill([
            'severity' => 1,
            'description' => "The SSL Certificate expires soon",
            'remediation' => 'Generate or expand the SSL certificate.',
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'SSLDATETOOLONG',
            'name' => 'SSL Certificate expiration date too late',
        ])->fill([
            'severity' => 4,
            'description' => "Enforce publicly trusted TLS server certificates have a lifetime of 398 days or less, if they are issued on or after 2020-09-01. Certificates that violate this will be rejected with ERR_CERT_VALIDITY_TOO_LONG and will be treated as misissued.",
            'remediation' => 'Enforce publicly trusted TLS server certificates have a lifetime of 398 days or less.',
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'SSLDATEEXPIRED',
            'name' => 'SSL Certificate expired',
        ])->fill([
            'severity' => 4,
            'description' => "The SSL Certificate has expired.",
            'remediation' => 'Generate a new SSL certificate.',
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'WP_USER_ENUM_AUTHOR',
            'name' => 'User enumeration: Author page',
        ])->fill([
            'severity' => 2,
            'description' => "If permalinks are enabled, in many WordPress installations it is possible to enumerate all the WordPress usernames iterating through the author archives. Whenever a post is published, the username or alias is shown as the author.",
            'attack_details' => "For example, the URL http://site.com/?author=1 will show all the posts from user id 1. Attackers can abuse this functionality to figure out which usernames are available on the site.",
            'remediation' => '[Fixing vulnerabilities guide: WP Enumeration - Author](https://netwerven.atlassian.net/wiki/display/SEC/Fixing+vulnerabilities+guide#Fixingvulnerabilitiesguide-Author)',
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'WP_USER_ENUM_FEED',
            'name' => 'User enumeration: Feed page',
        ])->fill([
            'severity' => 2,
            'description' => "If the feed page is enabled, the website might be leaking author usernames. Attackers might use a valid list of usernames to bruteforce the WP Admin panel later on.",
            'attack_details' => "http://site.com/?feed=rss2 might reveal usernames.",
            'remediation' => '[Fixing vulnerabilities guide: WP Enumeration - Feed](https://netwerven.atlassian.net/wiki/display/SEC/Fixing+vulnerabilities+guide#Fixingvulnerabilitiesguide-Feed)',
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'WP_USER_ENUM_WPAPI',
            'name' => 'User enumeration: WP API',
        ])->fill([
            'severity' => 2,
            'description' => "Using the WordPress API, unaithenticated attackers might be able to obtain fully information about users.",
            'attack_details' => "http://site.com/wp-json/wp/v2/users might reveal usernames.",
            'remediation' => '[Fixing vulnerabilities guide: WP Enumeration - WPAPI](https://netwerven.atlassian.net/wiki/display/SEC/Fixing+vulnerabilities+guide#Fixingvulnerabilitiesguide-WPAPI)',
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'WP_USER_ENUM_LOGIN',
            'name' => 'User enumeration: Login',
        ])->fill([
            'severity' => 1,
            'description' => "By default, the WordPress message for Incorrect credentials is not the same if the username exists or not.",
            'attack_details' => "Attacker might be able to, using a username list, get a valid list of common usernames,",
            'remediation' => '[Fixing vulnerabilities guide: WP Enumeration - Account login](https://netwerven.atlassian.net/wiki/display/SEC/Fixing+vulnerabilities+guide#Fixingvulnerabilitiesguide-AccountLogin)',
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'WP_LOGIN_UNRESTRICTED',
            'name' => 'Unrestricted Admin Panel',
        ])->fill([
            'severity' => 1,
            'description' => "By default, the WordPress login is accessible to anyone.",
            'attack_details' => "This might allow attackers to bruteforce or perform any other authentication attacks.",
            'remediation' => 'Is a good security remonandation to only allow logins to certain IPs.',
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'WAF_MISSING',
            'name' => 'Web Application Firewall not present',
        ])->fill([
            'severity' => 2,
            'description' => "A web application firewall (WAF) is an application firewall for HTTP applications. It applies a set of rules to an HTTP conversation. Generally, these rules cover common attacks such as cross-site scripting (XSS) and SQL injection.",
            'attack_details' => "Attackers will not be blocked when performing attacks such as XSS / SQLi.",
            'remediation' => 'Implement a Web Application Firewall',
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'OUTDATED',
            'name' => 'Outdated component',
        ])->fill([
            'severity' => 2,
            'description' => "Outdated software increases the risk of security breaches as they may contain vulnerabilities.",
            'attack_details' => "The outdated component might contain vulnerabilities or issues that can be exploited by the attackers.",
            'remediation' => 'Update the outdated component.',
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'WP_XMLRPC_UNRESTRICTED',
            'name' => 'Unrestricted XMLRPC',
        ])->fill([
            'severity' => 3,
            'description' => "WordPress XMLRPC interface is publicly accessible. In the past, multiple vulnerabilities where affecting this interface, and probably new ones will be discovered. [Should you disable XML-RPC on WordPress](https://www.wordfence.com/blog/2015/10/should-you-disable-xml-rpc-on-wordpress)",
            'attack_details' => "Attackers might be able to exploit vulnerabilities affecting XMLRPC, such as Pingback DDoS or users Brute-force.",
            'remediation' => 'If XMLRPC interface is not used, block it\'s access. [Fixing vulnerabilities guide: WP XMLRPC](https://netwerven.atlassian.net/wiki/spaces/SEC/pages/5571390/Fixing+vulnerabilities+guide#Fixingvulnerabilitiesguide-WordPress-XMLRPC)',
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'SSLSYMANTEC',
            'name' => 'Symantec Authority',
        ])->fill([
            'severity' => 3,
            'description' => 'Symantec certificates are no longer trusted by modern browsers like Google Chrome / Mozilla Firefox.',
            'attack_details' => 'https://security.googleblog.com/2017/09/chromes-plan-to-distrust-symantec.html',
            'remediation' => 'Generate a new SSL certificate using a different authority.',
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'DOMAIN_EXPIRES_SOON',
            'name' => 'The domain expires soon',
        ])->fill([
            'severity' => 1,
            'description' => "The domain expires soon.",
            'remediation' => 'Extend the domain registration.',
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'DOMAIN_EXPIRED',
            'name' => 'The domain has expired.',
        ])->fill([
            'severity' => 4,
            'description' => "Attackers might be able to take over the domain.",
            'remediation' => 'Register the domain again.',
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'HTTP',
            'name' => 'The website is served over HTTP',
        ])->fill([
            'severity' => 3,
            'description' => "The connection to the site is not encrypted.",
            'attack_details' => "Attackers on the same network, will be able to capture and modify requests.",
            'remediation' => 'Implement HTTPS.',
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'SSL_HEARTBLEED',
            'name' => 'SSL Heartbleed',
        ])->fill([
            'severity' => 4,
            'description' => "The Heartbleed Bug is a serious vulnerability in the popular OpenSSL cryptographic software library. This weakness allows stealing the information protected, under normal conditions, by the SSL/TLS encryption used to secure the Internet. SSL/TLS provides communication security and privacy over the Internet for applications such as web, email, instant messaging (IM) and some virtual private networks (VPNs).",
            'attack_details' => "The Heartbleed bug allows anyone on the Internet to read the memory of the systems protected by the vulnerable versions of the OpenSSL software. This compromises the secret keys used to identify the service providers and to encrypt the traffic, the names and passwords of the users and the actual content. This allows attackers to eavesdrop on communications, steal data directly from the services and users and to impersonate services and users.",
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'SSL_CCS',
            'name' => 'SSL CCS Injection',
        ])->fill([
            'severity' => 4,
            'description' => "OpenSSL’s ChangeCipherSpec processing has a serious vulnerability. This vulnerability allows malicious intermediate nodes to intercept encrypted data and decrypt them while forcing SSL clients to use weak keys which are exposed to the malicious nodes. Because both of servers and clients are affected by this vulnerabitlity, every OpenSSL user should update their software immediately. This vulnerabitlity has enough reproducibility and it is very likely for attackers to utilize this vulnerabitlity for target attacks.",
            'attack_details' => "Attackers can predict temporal encryption key materials of any communication by sending invalid signals in the handshake sessions. If attackers grasp the key materials, they can eavesdrop the encrypted communication or steal your identity.",
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'SSL_TICKETBLEED',
            'name' => 'SSL Ticketbleed',
        ])->fill([
            'severity' => 4,
            'description' => "Ticketbleed is a software vulnerability in the TLS/SSL stack of F5 BIG-IP appliances allowing a remote attacker to extract up to 31 bytes of uninitialized memory at a time. This memory can potentially contain key material or sensitive data from other connections. It is similar in spirit and implications to the well known Heartbleed vulnerability. It is different in that it exposes 31 bytes at a time instead of 64k, requiring more rounds to carry out an attack, and in that it affects the proprietary F5 TLS stack, not OpenSSL.",
            'attack_details' => "Attackers can extract memory of the systems.",
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'SSL_ROBOT',
            'name' => 'SSL ROBOT',
        ])->fill([
            'severity' => 4,
            'description' => "ROBOT is the return of a 19-year-old vulnerability that allows performing RSA decryption and signing operations with the private key of a TLS server.",
            'attack_details' => "For hosts that are vulnerable and only support RSA encryption key exchanges it's pretty bad. It means an attacker can passively record traffic and later decrypt it. For hosts that usually use forward secrecy, but still support a vulnerable RSA encryption key exchange the risk depends on how fast an attacker is able to perform the attack. We believe that a server impersonation or man in the middle attack is possible, but it is more challenging.",
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'SSL_SECURE_RENEGO',
            'name' => 'TLS Session Renegotiation',
        ])->fill([
            'severity' => 4,
            'description' => "The TLS protocol, and the SSL protocol 3.0 and possibly earlier, as used in Microsoft Internet Information Services (IIS) 7.0, mod_ssl in the Apache HTTP Server 2.2.14 and earlier, OpenSSL before 0.9.8l, GnuTLS 2.8.5 and earlier, Mozilla Network Security Services (NSS) 3.12.4 and earlier, multiple Cisco products, and other products, does not properly associate renegotiation handshakes with an existing connection.",
            'attack_details' => "Allows man-in-the-middle attackers to insert data into HTTPS sessions, and possibly other types of sessions protected by TLS or SSL, by sending an unauthenticated request that is processed retroactively by a server in a post-renegotiation context, related to a 'plaintext injection' attack, aka the 'Project Mogul' issue.",
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'SSL_CRIME_TLS',
            'name' => 'SSL CRIME',
        ])->fill([
            'severity' => 4,
            'description' => "The TLS protocol 1.2 and earlier, as used in Mozilla Firefox, Google Chrome, Qt, and other products, can encrypt compressed data without properly obfuscating the length of the unencrypted data.",
            'attack_details' => "Allows man-in-the-middle attackers to obtain plaintext HTTP headers by observing length differences during a series of guesses in which a string in an HTTP request potentially matches an unknown string in an HTTP header, aka a 'CRIME' attack.",
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'SSL_BREACH',
            'name' => 'SSL BREACH',
        ])->fill([
            'severity' => 4,
            'description' => "The BREACH vulnerability allows attackers to discover secrets wrapped in HTTP compression inside of SSL. By injecting plaintext into an HTTPS request, an attacker can learn information about the corresponding HTTPS response by measuring its size. This action relies on the attacker's ability to observe the size of the ciphertext received by the browser while triggering a number of strategically crafted requests to a target site.",
            'attack_details' => "By observing the length of compressed HTTPS responses, an attacker may be able to obtain plaintext secrets from the ciphertext of an HTTPS stream.",
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'SSL_POODLE',
            'name' => 'SSL POODLE',
        ])->fill([
            'severity' => 4,
            'description' => "The SSL protocol 3.0, as used in OpenSSL through 1.0.1i and other products, uses nondeterministic CBC padding.",
            'attack_details' => "Makes it easier for man-in-the-middle attackers to obtain cleartext data via a padding-oracle attack, aka the 'POODLE' issue.",
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'SSL_FALLBACK_SCSV',
            'name' => 'SSL Fallback SCSV',
        ])->fill([
            'severity' => 4,
            'description' => "TLS Fallback SCSV mechanism is not enabled",
            'attack_details' => "Attackers might be able to downgrade the connection.",
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'SSL_SWEET32',
            'name' => 'SSL SWEET32',
        ])->fill([
            'severity' => 4,
            'description' => "Because DES (and triple-DES) has only a 64-bit block size, birthday attacks are a real concern. With the ability to run Javascript in a browser, it is possible to send enough traffic to cause a collision, and then use that information to recover something like a session Cookie. Their experiments have been able to recover a cookie in under two days. More details are available at their website. But the take-away is this: triple-DES should now be considered as “bad” as RC4.",
            'attack_details' => "The DES ciphers (and triple-DES) only have a 64-bit block size. This enables an attacker to run JavaScript in a browser and send large amounts of traffic during the same TLS connection, creating a collision. With this collision, the attacker is able to retrieve information from a session cookie.",
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'SSL_FREAK',
            'name' => 'SSL FREAK',
        ])->fill([
            'severity' => 4,
            'description' => "The ssl3_get_key_exchange function in s3_clnt.c in OpenSSL before 0.9.8zd, 1.0.0 before 1.0.0p, and 1.0.1 before 1.0.1k allows remote SSL servers to conduct RSA-to-EXPORT_RSA downgrade attacks and facilitate brute-force decryption by offering a weak ephemeral RSA key in a noncompliant role, related to the 'FREAK' issue.",
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'SSL_DROWN',
            'name' => 'SSL DROWN',
        ])->fill([
            'severity' => 4,
            'description' => "DROWN is a serious vulnerability that affects HTTPS and other services that rely on SSL and TLS, some of the essential cryptographic protocols for Internet security. These protocols allow everyone on the Internet to browse the web, use email, shop online, and send instant messages without third-parties being able to read the communication.",
            'attack_details' => "DROWN allows attackers to break the encryption and read or steal sensitive communications, including passwords, credit card numbers, trade secrets, or financial data. Our measurements indicate 33% of all HTTPS servers are vulnerable to the attack.",
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'SSL_LOGJAM',
            'name' => 'SSL Logjam',
        ])->fill([
            'severity' => 4,
            'description' => "The TLS protocol 1.2 and earlier, when a DHE_EXPORT ciphersuite is enabled on a server but not on a client, does not properly convey a DHE_EXPORT choice.",
            'attack_details' => "allows man-in-the-middle attackers to conduct cipher-downgrade attacks by rewriting a ClientHello with DHE replaced by DHE_EXPORT and then rewriting a ServerHello with DHE_EXPORT replaced by DHE, aka the 'Logjam' issue.",
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'SSL_BEAST',
            'name' => 'SSL BEAST',
        ])->fill([
            'severity' => 4,
            'description' => "The SSL protocol, as used in certain configurations in Microsoft Windows and Microsoft Internet Explorer, Mozilla Firefox, Google Chrome, Opera, and other products, encrypts data by using CBC mode with chained initialization vectors.",
            'attack_details' => "Allows man-in-the-middle attackers to obtain plaintext HTTP headers via a blockwise chosen-boundary attack (BCBA) on an HTTPS session, in conjunction with JavaScript code that uses (1) the HTML5 WebSocket API, (2) the Java URLConnection API, or (3) the Silverlight WebClient API, aka a 'BEAST' attack.",
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'SSL_LUCKY13',
            'name' => 'SSL Lucky Thirteen',
        ])->fill([
            'severity' => 4,
            'description' => "The TLS protocol 1.1 and 1.2 and the DTLS protocol 1.0 and 1.2, as used in OpenSSL, OpenJDK, PolarSSL, and other products, do not properly consider timing side-channel attacks on a MAC check requirement during the processing of malformed CBC padding.",
            'attack_details' => "Allows remote attackers to conduct distinguishing attacks and plaintext-recovery attacks via statistical analysis of timing data for crafted packets, aka the 'Lucky Thirteen' issue.",
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'SSL_RC4',
            'name' => 'SSL RC4',
        ])->fill([
            'severity' => 4,
            'description' => "The RC4 algorithm, as used in the TLS protocol and SSL protocol, has many single-byte biases.",
            'attack_details' => "Makes it easier for remote attackers to conduct plaintext-recovery attacks via statistical analysis of ciphertext in a large number of sessions that use the same plaintext.",
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'SSL_TLS_1_0',
            'name' => 'TLS 1.0 is Offered',
        ])->fill([
            'severity' => 4,
            'description' => "TLS 1.0 is an obsolete protocol and should be replaced by TLS 1.2 or 1.3.",
            'attack_details' => "",
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'SSL_TLS_1_1',
            'name' => 'TLS 1.1 is Offered',
        ])->fill([
            'severity' => 4,
            'description' => "TLS 1.1 is an obsolete protocol and should be replaced by TLS 1.2 or 1.3.",
            'attack_details' => "",
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'SUBDOMAIN_TAKEOVER',
            'name' => 'Subdomain Takeover',
        ])->fill([
            'severity' => 4,
            'description' => "Subdomain takeover is a process of registering a non-existing domain name to gain control over another domain. The implications of the subdomain takeover can be pretty significant.",
            'attack_details' => "Attackers can send phishing emails from the legitimate domain, perform cross-site scripting (XSS), or damage the reputation of the brand which is associated with the domain. You can read more about implications (risks) in my other post.",
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'DNS_ZONE_TRASNFER',
            'name' => 'DNS Zone Transfer',
        ])->fill([
            'severity' => 3,
            'description' => "DNS Zone transfer is the process where a DNS server passes a copy of part of it's database (which is called a 'zone') to another DNS server. It's how you can have more than one DNS server able to answer queries about a particular zone; there is a Master DNS server, and one or more Slave DNS servers, and the slaves ask the master for a copy of the records for that zone.",
            'attack_details' => "A basic DNS Zone Transfer Attack isn't very fancy: you just pretend you are a slave and ask the master for a copy of the zone records. And it sends you them; DNS is one of those really old-school Internet protocols that was designed when everyone on the Internet literally knew everyone else's name and address, and so servers trusted each other implicitly.",
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'MX_ISSUES',
            'name' => 'MX Issues',
        ])->fill([
            'severity' => 2,
            'description' => "General MX DNS record issues.",
            'attack_details' => "",
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'SPF_ISSUES',
            'name' => 'SPF Issues',
        ])->fill([
            'severity' => 2,
            'description' => "An SPF record is a type of DNS record that identifies which mail servers are permitted to send email on behalf of your domain. The purpose of an SPF record is to prevent spammers from sending messages with forged From addresses at your domain.",
            'attack_details' => "Attackers could send emails using the vulnerable domain, bypassing phishing / spam filters (email spoofing). Detailed checks: https://www.kitterman.com/spf/validate.html.\n\nProof of concept: https://emkei.cz/",
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'DMARC_ISSUES',
            'name' => 'DMARC Issues',
        ])->fill([
            'severity' => 2,
            'description' => "DMARC, or Domain-Based Message Authentication Reporting and Conformance, is an added authentication method that uses both SPF and DKIM to verify whether or not an email was actually sent by the owner of the “Friendly-From” domain that the user sees. In order for DMARC to pass, both SPF and DKIM must pass, and at least one of them must be aligned.",
            'attack_details' => "Attackers could send emails using the vulnerable domain, bypassing phishing / spam filters (email spoofing). . Detailed checks: https://www.kitterman.com/spf/validate.html.\n\nProof of concept: https://emkei.cz/",
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'HOST_HEADER_INJECTION',
            'name' => 'Host Header Injection ',
        ])->fill([
            'severity' => 2,
            'description' => "It is common practice for the same web server to host several websites or web applications on the same IP address. This why the host header exists. The host header specifies which website or web application should process an incoming HTTP request. The web server uses the value of this header to dispatch the request to the specified website or web application. Each web application hosted on the same IP address is commonly referred to as a virtual host.",
            'attack_details' => "Most web servers are configured to pass the unrecognized host header to the first virtual host in the list. Therefore, it’s possible to send requests with arbitrary host headers to the first virtual host. Most web servers are configured to pass the unrecognized host header to the first virtual host in the list. Therefore, it’s possible to send requests with arbitrary host headers to the first virtual host.",
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'EXPOSED_VCS',
            'name' => 'Exposed Version Control System ',
        ])->fill([
            'severity' => 5,
            'description' => "An information disclosure vulnerability has been reported in GIT / SVN Repository.",
            'attack_details' => "Successful exploitation of this vulnerability could allow an unintentional disclosure of account information.",
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'HOST_HEADER_IP_LEAK',
            'name' => 'Host Header IP Leak',
        ])->fill([
            'severity' => 1,
            'description' => "The web server leaks its internal IP address when sending an HTTP/1.0 request without a Host header.",
            'attack_details' => "Attackers could reveal the internal IP of the server, which aparently is different from the public one.",
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'UNRESTRICTED_API_KEY',
            'name' => 'Unrestricted API key',
        ])->fill([
            'severity' => 4,
            'description' => "The API key found is not restricted or limited. [Google Maps API bugs](https://medium.com/bugbountywriteup/google-maps-api-not-the-key-bugs-that-i-found-over-the-years-781840fc82aa)",
            'attack_details' => "Attackers could consume the company’s monthly quota or can over-bill with unauthorized usage of this service and do financial damage to the company, if the company does not have any limitation settings on API budgets; or conduct a denial of service attack specific to the service if any limitation of maximum bill control settings exist in the Google account. While this could not be too dangerous if used the application parts of such “Contact Us” pages, however it could be really dangerous if the main business/functionality of the app is handled within these maps such as Uber (Finding/tracking rides via Maps) and Booking (Searching hotels via Maps).",
            'remediation' => 'Limit the API key to be only used from the website or the website resources. ',
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'MIXED_CONTENT',
            'name' => 'Mixed Content',
        ])->fill([
            'severity' => 2,
            'description' => "HTML is loaded over a secure HTTPS connection, but other resources (such as images, videos, stylesheets, scripts) are loaded over an insecure HTTP connection.",
            'attack_details' => "An attacker suitably positioned to view a legitimate user's network traffic could record and monitor their interactions with these resources, which may indirectly disclose information about the user's activity on the application itself. Furthermore, an attacker able to modify traffic could alter these resources and potentially influence the application's appearance and behavior.",
            'remediation' => 'Ensure that all external resources the page references are loaded using HTTPS.',
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'LEAKED_CREDENTIALS',
            'name' => 'Leaked credentials',
        ])->fill([
            'severity' => 4,
            'description' => "Credentials found in a repository.",
            'attack_details' => "Attackers can use those credentials to access protected resources.",
            'remediation' => "Remove the exposed credentials from the repository source code and the git history.",
        ])->save();

        VulnerabilityType::firstOrCreate([
            'code' => 'WEAK_PASSWORD',
            'name' => 'Weak Password',
        ])->fill([
            'severity' => 5,
            'description' => 'A working login and password was guessed.',
            'attack_details' => 'Attackers could successfully brute-force the service and gain access.',
            'remediation' => 'Change the guessed account credentials to a strong one and if possible implement a password policy.',
        ])->save();
    }
}
